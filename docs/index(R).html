<!DOCTYPE html>
<html lang="en-us">

<head>
  <meta charset="UTF-8">
  <title>Project 1</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
  <script type="text/javascript" src="d3/d3.v3.min.js"></script>
  <script type="text/javascript" src="three/three.min.js"></script>

  <style type="text/css">
    .button {
      background-color: #4CAF50;
      border: none;
      color: white;
      padding: 15px 32px;
      text-align: center;
      text-decoration: none;
      display: inline-block;
      font-size: 16px;
    }

    .wrapper {
      text-align: center;
	}
	
	.radioButtons{
		position: relative;
		top: 200px;
		left: -300px;
		text-align:center;
		height: auto;
		width: auto;
		
	}
  </style>
</head>

<body>
  <section class="page-header">
  </section>
  <section class="main-content">
  
<!---------- Clustering START ---------->
	<div class="radioButtons" >
		<form action="">
			<input type="radio" name="radioCluster" class="rc" value="Noise - Residential" checked> Noise - Residential <br>
			<input type="radio" name="radioCluster" class="rc" value="Illegal Parking"> Illegal Parking <br>
			<input type="radio" name="radioCluster" class="rc" value="Unsanitary Condition"> Unsanitary Condition <br>
			<input type="radio" name="radioCluster" class="rc" value="Homeless Person Assistance"> Homeless Person Assistance <br>
			<input type="radio" name="radioCluster" class="rc" value="Rodent"> Rodent
		</form>
	</div>
    <div class='wrapper' id='geoMapGoesHere'>
		<h1>Clustering</h1>
		<script type="text/javascript">
			var w = 1000;
			var h = 600;
			var k = 2;
			var kprv = 2;
			var dk = 0;

			var color = 'skyblue';
			var complaints = [];

			var projection = d3.geo.mercator()
			  .center([-73.94, 40.70])
			  .translate([w / 2, h / 2])
			  .scale([60000]);

			var path = d3.geo.path()
			  .projection(projection);

			var geoMap = d3.select('#geoMapGoesHere')
			  .append('svg')
			  .attr("width", w)
			  .attr("height", h);

			  
			var complaints = [];
			var clusters = [[[]]];
			var nCluster = 2;
			var j = 1;
			var colorMapping = {};
			
			colorMapping[0] = 'purple';
			colorMapping[1] = 'green';
			colorMapping[2] = 'red';
			colorMapping[3] = 'blue';
			colorMapping[4] = 'skyblue';
			colorMapping[5] = 'orange';
			
			//Changing dataset START
			var selectedDataset = d3.select('input[name=radioCluster]:checked').attr('value')
			console.log(selectedDataset)
			
			d3.json("dataset/NYCZip.geojson", function(json) {
			  geoMap.selectAll("path")
				.data(json.features)
				.enter()
				.append("path")
				.attr("d", path);
			d3.csv('dataset/Homeless Person Assistance_Clustering.csv', function(d0){
				d3.csv('dataset/Illegal Parking_Clustering.csv', function(d1){
					d3.csv('dataset/Noise - Residential_Clustering.csv', function(d2){
						d3.csv('dataset/Rodent_Clustering.csv', function(d3){
							d3.csv('dataset/UNSANITARY CONDITION_Clustering.csv', function(d4){
								dataset = []
								dataset.push(d0)
								dataset.push(d1)
								dataset.push(d2)
								dataset.push(d3)
								dataset.push(d4)
								complaints = []

								d3.selectAll("input[name='radioCluster']").on("change", function(){
									geoMap.selectAll('.centroids')
										.remove()
									geoMap.selectAll('.complaints')
										.remove()
									
									selectedDataset = this.value
									console.log(selectedDataset)
								});
								for (var z = 0; z < 5; z++) {
									var temparr = [];
									for (var i = 0; i < dataset[z].length; i++) {
										if (Number(dataset[z][i]['2']) == -1 || Number(dataset[z][i]['2']) >= 10) break;
										temparr.push([Number(dataset[z][i]['lat']), Number(dataset[z][i]['lon']), Number(dataset[z][i]['2']), Number(dataset[z][i]['3']), Number(dataset[z][i]['4']), Number(dataset[z][i]['5']), Number(dataset[z][i]['6'])])
									}
									complaints.push(temparr);
									temparr = [[]];
									for ( ; i < d.length; i++){
										if (j > nCluster){
											nCluster += 1;
											if (nCluster == 7){
												break;
											}
											temparr.push([]);
											j = 1;
										}
										temparr[temparr.length - 1].push([dataset[z][i]['lat'], dataset[z][i]['lon'], nCluster, j]);
										j += 1
									}
									clusters.push(temparr);

								   	geoMap.selectAll('.complaints' + z)
										.data(complaints[z])
										.enter()
										.append('circle')
										.attr('cx', function(d){
											return projection([d[1], d[0]])[0];
										})
										.attr('cy', function(d){
											return projection([d[1], d[0]])[1];
										})
										.attr('r', 3)
										.attr('class', 'complaints' + z)
										.style('opacity', 0.5)
										.style('fill', function(d){
											return colorMapping[d[k]];
										});
						                   
									geoMap.selectAll('.centroids' + z)
										.data(clusters[z][k-2])
										.enter()
										.append('circle')
										.attr('cx', function(d){
											return projection([d[1], d[0]])[0];
										})
										.attr('cy', function(d){
											return projection([d[1], d[0]])[1];
										})
										.attr('r', 15)
										.attr('class', 'centroids' + z)
										.style('stroke-width', 4)
										.style('stroke', 'white')
										.style('fill', 'none');
							   	}
							   
				                   
								d3.select('#k2')
								.on('mouseover', function(){
									kprv = k;
									k = 2;
									update();
								})
								.on('mouseout', function(){
								k = kprv;
								update();
								})
								.on('click', function(){
									k = 2;
									kprv = 2;
									update();
								});
								d3.select('#k3')
								.on('mouseover', function(){
									kprv = k;
									k = 3;
									update();
								})
								.on('mouseout', function(){
									k = kprv;
									update();
								})
								.on('click', function(){
									k = 3;
									kprv = 3;
									update();
								});
								d3.select('#k4')
								.on('mouseover', function(){
									kprv = k;
									k = 4;
									update();
								})
								.on('mouseout', function(){
									k = kprv;
									update();
								})
								.on('click', function(){
									k = 4;
									kprv = 4;
									update();
								});
								d3.select('#k5')
								.on('mouseover', function(){
									kprv = k;
									k = 5;
									update();
								})
								.on('mouseout', function(){
									k = kprv;
									update();
								})
								.on('click', function(){
									k = 5;
									kprv = 5;
									update();
								});
								d3.select('#k6')
								.on('mouseover', function(){
									kprv = k;
									k = 6;
									update();
								})
								.on('mouseout', function(){
									k = kprv;
									update();
								})
								.on('click', function(){
									k = 6;
									kprv = 6;
									update();
								});
								geoMap.append('text')
								.attr('x', 300)
								.attr('y', 100)
								.attr("text-anchor", "middle")  
								.style("font-size", "20px") 
								.style("text-decoration", "underline")  
								.text(function(){
									return 'K = ' + k;
								})
								.attr('class', 'ktitle');
				                   
								function update(){
									geoMap.selectAll('.complaints')
									.data(complaints)
									.style('fill', function(d){
										return colorMapping[dataset[dk][k]];
									});
									geoMap.selectAll('.centroids')
									.remove()
									geoMap.selectAll('.centroids')
									.data(clusters[k-2])
									.enter()
									.append('circle')
									.attr('cx', function(d){
										return projection([dataset[dk][1], dataset[dk][0]])[0];
									})
									.attr('cy', function(d){
										return projection([dataset[dk][1], dataset[dk][0]])[1];
									})
									.attr('r', 15)
									.attr('class', 'centroids')
									.style('stroke-width', 4)
									.style('stroke', 'white')
									.style('fill', 'none');
									geoMap.select('.ktitle')
									.text(function(){
										return 'K = ' + k;
									})
								}	
							});
						});
					});
				});
			});
		});
		  </script>
		<div class='wrapper' id='buttons'>
			<input type="button" class="button" value="K = 2" id='k2'>
			<input type="button" class="button" value="K = 3" id='k3'>
			<input type="button" class="button" value="K = 4" id='k4'>
			<input type="button" class="button" value="K = 5" id='k5'>
			<input type="button" class="button" value="K = 6" id='k6'>
		</div>
		<p>
		Above is the map of New York on the left side of the map, it's possible to select which dataset you want to see visualized and below the map you can choose how many clusters you want to divide the data into. <br>
		The type of clustering we used above is <b>K</b>-means, and by using clustering we are able to find a structure in the data only by analyzing the otherwise unstructured data. The white rings are located at the center of the clusters and as we increase the number of clusters we can see the circles increase in precession. 
		</p>
	</div>

<!---------- Clustering END ---------->

<!---------- Multiple regression START ---------->
	<div class="radioButtons" >
		<form action="">
			<input type="radio" name="radioRegression" value="Noise - Residential" checked> Noise - Residential <br>
			<input type="radio" name="radioRegression" value="Illegal Parking"> Illegal Parking <br>
			<input type="radio" name="radioRegression" value="Unsanitary Condition"> Unsanitary Condition <br>
			<input type="radio" name="radioRegression" value="Homeless Person Assistance"> Homeless Person Assistance <br>
			<input type="radio" name="radioRegression" value="Rodent"> Rodent
		</form>
	</div>
	<div class="wrapper" id="3dPlotGoesHere">
		<h1>Multiple Regression</h1>
		<script type="text/javascript">
		// 3D Scatter Plot
		function createTextCanvas(text, color, font, size) {
        size = size || 16;
        var canvas = document.createElement('canvas');
        var ctx = canvas.getContext('2d');
        var fontStr = (size + 'px ') + (font || 'Arial');
        ctx.font = fontStr;
        var w = ctx.measureText(text).width;
        var h = Math.ceil(size);
        canvas.width = w;
        canvas.height = h;
        ctx.font = fontStr;
        ctx.fillStyle = color || 'black';
        ctx.fillText(text, 0, Math.ceil(size * 0.8));
        return canvas;
    }

    function createText2D(text, color, font, size, segW, segH) {
        var canvas = createTextCanvas(text, color, font, size);
        var plane = new THREE.PlaneGeometry(canvas.width, canvas.height, segW, segH);
        var tex = new THREE.Texture(canvas);
        tex.needsUpdate = true;
        var planeMat = new THREE.MeshBasicMaterial({
            map: tex,
            color: 0xffffff,
            transparent: true
        });
        var mesh = new THREE.Mesh(plane, planeMat);
        mesh.scale.set(0.5, 0.5, 0.5);
        mesh.doubleSided = true;
        return mesh;
    }

    // from http://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb
    function hexToRgb(hex) { //TODO rewrite with vector output
        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        } : null;
    }

    var renderer = new THREE.WebGLRenderer({
        antialias: true
    });
    var w = 1000;
    var h = 540;
    renderer.setSize(w, h);
	
    document.getElementById("3dPlotGoesHere").appendChild(renderer.domElement);

    renderer.setClearColor(0xffffff, 1);

    var camera = new THREE.PerspectiveCamera(45, w / h, 1, 10000);
    camera.position.z = 200;
    camera.position.x = -100;
    camera.position.y = 100;

    var scene = new THREE.Scene();

    var scatterPlot = new THREE.Object3D();
    scene.add(scatterPlot);

    scatterPlot.rotation.y = 0;

    function v(x, y, z) {
        return new THREE.Vector3(x, y, z);
    }

    var unfiltered = [];

    var format = d3.format("+.3f");

    var data = d3.csv("dataset/Noise - Residential_XYZ.csv", function (d) {
	        d.forEach(function (d,i) {
            unfilteredataset[z][i] = {
                x: +d.X,
                y: +d.Y,
                z: +d.Z
            }
        })

    var xExent = d3.extent(unfiltered, function (d) {return d.x; }),
        yExent = d3.extent(unfiltered, function (d) {return d.y; }),
        zExent = d3.extent(unfiltered, function (d) {return d.z; });

    var vpts = {
        xMax: xExent[1],
        xCen: (xExent[1] + xExent[0]) / 2,
        xMin: xExent[0],
        yMax: yExent[1],
        yCen: (yExent[1] + yExent[0]) / 2,
        yMin: yExent[0],
        zMax: zExent[1],
        zCen: (zExent[1] + zExent[0]) / 2,
        zMin: zExent[0]
    }

    var colour = d3.scale.category20c();

    var xScale = d3.scale.linear()
                  .domain(xExent)
                  .range([-50,50]);
    var yScale = d3.scale.linear()
                  .domain(yExent)
                  .range([-50,50]);                  
    var zScale = d3.scale.linear()
                  .domain(zExent)
                  .range([-50,50]);

    var lineGeo = new THREE.Geometry();
    lineGeo.vertices.push(
        v(xScale(vpts.xMin), yScale(vpts.yCen), zScale(vpts.zCen)), v(xScale(vpts.xMax), yScale(vpts.yCen), zScale(vpts.zCen)),
        v(xScale(vpts.xCen), yScale(vpts.yMin), zScale(vpts.zCen)), v(xScale(vpts.xCen), yScale(vpts.yMax), zScale(vpts.zCen)),
        v(xScale(vpts.xCen), yScale(vpts.yCen), zScale(vpts.zMax)), v(xScale(vpts.xCen), yScale(vpts.yCen), zScale(vpts.zMin)),

        v(xScale(vpts.xMin), yScale(vpts.yMax), zScale(vpts.zMin)), v(xScale(vpts.xMax), yScale(vpts.yMax), zScale(vpts.zMin)),
        v(xScale(vpts.xMin), yScale(vpts.yMin), zScale(vpts.zMin)), v(xScale(vpts.xMax), yScale(vpts.yMin), zScale(vpts.zMin)),
        v(xScale(vpts.xMin), yScale(vpts.yMax), zScale(vpts.zMax)), v(xScale(vpts.xMax), yScale(vpts.yMax), zScale(vpts.zMax)),
        v(xScale(vpts.xMin), yScale(vpts.yMin), zScale(vpts.zMax)), v(xScale(vpts.xMax), yScale(vpts.yMin), zScale(vpts.zMax)),

        v(xScale(vpts.xMin), yScale(vpts.yCen), zScale(vpts.zMax)), v(xScale(vpts.xMax), yScale(vpts.yCen), zScale(vpts.zMax)),
        v(xScale(vpts.xMin), yScale(vpts.yCen), zScale(vpts.zMin)), v(xScale(vpts.xMax), yScale(vpts.yCen), zScale(vpts.zMin)),
        v(xScale(vpts.xMin), yScale(vpts.yMax), zScale(vpts.zCen)), v(xScale(vpts.xMax), yScale(vpts.yMax), zScale(vpts.zCen)),
        v(xScale(vpts.xMin), yScale(vpts.yMin), zScale(vpts.zCen)), v(xScale(vpts.xMax), yScale(vpts.yMin), zScale(vpts.zCen)),

        v(xScale(vpts.xMax), yScale(vpts.yMin), zScale(vpts.zMin)), v(xScale(vpts.xMax), yScale(vpts.yMax), zScale(vpts.zMin)),
        v(xScale(vpts.xMin), yScale(vpts.yMin), zScale(vpts.zMin)), v(xScale(vpts.xMin), yScale(vpts.yMax), zScale(vpts.zMin)),
        v(xScale(vpts.xMax), yScale(vpts.yMin), zScale(vpts.zMax)), v(xScale(vpts.xMax), yScale(vpts.yMax), zScale(vpts.zMax)),
        v(xScale(vpts.xMin), yScale(vpts.yMin), zScale(vpts.zMax)), v(xScale(vpts.xMin), yScale(vpts.yMax), zScale(vpts.zMax)),

        v(xScale(vpts.xCen), yScale(vpts.yMin), zScale(vpts.zMax)), v(xScale(vpts.xCen), yScale(vpts.yMax), zScale(vpts.zMax)),
        v(xScale(vpts.xCen), yScale(vpts.yMin), zScale(vpts.zMin)), v(xScale(vpts.xCen), yScale(vpts.yMax), zScale(vpts.zMin)),
        v(xScale(vpts.xMax), yScale(vpts.yMin), zScale(vpts.zCen)), v(xScale(vpts.xMax), yScale(vpts.yMax), zScale(vpts.zCen)),
        v(xScale(vpts.xMin), yScale(vpts.yMin), zScale(vpts.zCen)), v(xScale(vpts.xMin), yScale(vpts.yMax), zScale(vpts.zCen)),

        v(xScale(vpts.xMax), yScale(vpts.yMax), zScale(vpts.zMin)), v(xScale(vpts.xMax), yScale(vpts.yMax), zScale(vpts.zMax)),
        v(xScale(vpts.xMax), yScale(vpts.yMin), zScale(vpts.zMin)), v(xScale(vpts.xMax), yScale(vpts.yMin), zScale(vpts.zMax)),
        v(xScale(vpts.xMin), yScale(vpts.yMax), zScale(vpts.zMin)), v(xScale(vpts.xMin), yScale(vpts.yMax), zScale(vpts.zMax)),
        v(xScale(vpts.xMin), yScale(vpts.yMin), zScale(vpts.zMin)), v(xScale(vpts.xMin), yScale(vpts.yMin), zScale(vpts.zMax)),

        v(xScale(vpts.xMin), yScale(vpts.yCen), zScale(vpts.zMin)), v(xScale(vpts.xMin), yScale(vpts.yCen), zScale(vpts.zMax)),
        v(xScale(vpts.xMax), yScale(vpts.yCen), zScale(vpts.zMin)), v(xScale(vpts.xMax), yScale(vpts.yCen), zScale(vpts.zMax)),
        v(xScale(vpts.xCen), yScale(vpts.yMax), zScale(vpts.zMin)), v(xScale(vpts.xCen), yScale(vpts.yMax), zScale(vpts.zMin)),
        v(xScale(vpts.xCen), yScale(vpts.yMin), zScale(vpts.zMin)), v(xScale(vpts.xCen), yScale(vpts.yMin), zScale(vpts.zMax))

    );
    var lineMat = new THREE.LineBasicMaterial({
        color: 0xdcdcdc,
        lineWidth: 2
    });
    var line = new THREE.Line(lineGeo, lineMat);
    line.type = THREE.Lines;
    scatterPlot.add(line);

    var titleX = createText2D('Time');
    titleX.position.x = xScale(vpts.xMin) - 12,
    titleX.position.y = 5;
    scatterPlot.add(titleX);

    var valueX = createText2D(0);
    valueX.position.x = xScale(vpts.xMin) - 12,
    valueX.position.y = -5;
    scatterPlot.add(valueX);

    var titleX = createText2D('Time');
    titleX.position.x = xScale(vpts.xMax) + 12;
    titleX.position.y = 5;
    scatterPlot.add(titleX);

    var valueX = createText2D(24);
    valueX.position.x = xScale(vpts.xMax) + 12,
    valueX.position.y = -5;
    scatterPlot.add(valueX);

    var titleY = createText2D('Total amount of complaints');
    titleY.position.y = yScale(vpts.yMin) - 5;
    scatterPlot.add(titleY);

    var valueY = createText2D(0);
    valueY.position.y = yScale(vpts.yMin) - 15,
    scatterPlot.add(valueY);

    var titleY = createText2D('Total amount of complaints');
    titleY.position.y = yScale(vpts.yMax) + 15;
    scatterPlot.add(titleY);

    var valueY = createText2D(869);
    valueY.position.y = yScale(vpts.yMax) + 5,
    scatterPlot.add(valueY);

    var titleZ = createText2D('Amount of Noise - Residential complaints ');
    titleZ.position.z = zScale(vpts.zMax) + 2;
    scatterPlot.add(titleZ);
	
	var valueZ = createText2D(format(zExent[1]));
    valueZ.position.z = zScale(vpts.zMax) + 2,
	valueZ.position.y = zScale(vpts.zMax) - 60,
    scatterPlot.add(valueZ);

    var mat = new THREE.ParticleBasicMaterial({
        vertexColors: true,
        size: 5
    });
	
    var pointCount = unfiltered.length;
    var pointGeo = new THREE.Geometry();
    for (var i = 0; i < pointCount; i ++) {
        var x = xScale(unfilteredataset[z][i].x);
        var y = yScale(unfilteredataset[z][i].y);
        var z = zScale(unfilteredataset[z][i].z);

		pointGeo.vertices.push(new THREE.Vector3(x, y, z));
        pointGeo.colors.push(new THREE.Color().setRGB(
          hexToRgb(colour(i)).r / 255, hexToRgb(colour(i)).g / 255, hexToRgb(colour(i)).b / 255 
        ));

    }
    var points = new THREE.Points(pointGeo, mat);
    scatterPlot.add(points);

    renderer.render(scene, camera);
    var paused = false;
    var last = new Date().getTime();
    var down = false;
    var sx = 0,
        sy = 0;
        
    window.onmousedown = function(ev) {
        down = true;
        sx = ev.clientX;
        sy = ev.clientY;
    };
    window.onmouseup = function() {
        down = false;
    };
    window.onmousemove = function(ev) {
        if (down) {
            var dx = ev.clientX - sx;
            var dy = ev.clientY - sy;
            scatterPlot.rotation.y += dx * 0.01;
            camera.position.y += dy;
            sx += dx;
            sy += dy;
        }
    }
    var animating = false;
    window.ondblclick = function() {
        animating = !animating;
    };

    function animate(t) {
        if (!paused) {
            last = t;
            if (animating) {
                var v = pointGeo.vertices;
                for (var i = 0; i < v.length; i++) {
                    var u = v[i];
                    console.log(u)
                    u.angle += u.speed * 0.01;
                    u.x = Math.cos(u.angle) * u.radius;
                    u.z = Math.sin(u.angle) * u.radius;
                }
                pointGeo.__dirtyVertices = true;
            }
            renderer.clear();
            camera.lookAt(scene.position);
            renderer.render(scene, camera);
        }
        window.requestAnimationFrame(animate, renderer.domElement);
    };
    animate(new Date().getTime());
    onmessage = function(ev) {
        paused = (ev.data == 'pause');
    };

    })
		</script>
		<p>
 		The interactive 3D-graph above is a visualization of a multiple regression analysis, it’s possible to change which dataset you want visualized by using the radio buttons on the left, the colors doesn’t mean anything they are different simply so it’s easier to tell the difference between each point. <br>
		Multiple regression, is used when you have more than one covariant to predict from, we use a part of our data to fit our model to help it predict the rest of our data. 
		</p>
	</div>

<!---------- Multiple regression END ---------->

	</section>
</body>
